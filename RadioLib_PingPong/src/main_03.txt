/*
    modified and combined Example Ping-Pong [OE3WAS]

   RadioLib Transmit with Interrupts Example
   RadioLib Receive with Interrupts Example

   This example transmits packets using SX1276/SX1278/SX1262/SX1268 LoRa radio module.
   Each packet contains up to 256 bytes of data, in the form of:
    - Arduino String
    - null-terminated char array (C-string)
    - arbitrary binary data (byte array)

   This example listens for LoRa transmissions and tries to receive them.
   Once a packet is received, an interrupt is triggered.

   For both transmitter and receiver are the same following settings: 
    - carrier frequency
    - bandwidth
    - spreading factor
    - coding rate
    - sync word

   For full API reference, see the GitHub Pages
   https://jgromes.github.io/RadioLib/
*/

#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <esp_mac.h>
#include "soc/rtc.h"

#if defined(ARDUINO_ARCH_ESP32)
#if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(5,0,0)
#include "hal/gpio_hal.h"
#endif
#include "driver/gpio.h"
#endif //ARDUINO_ARCH_ESP32

#include <U8g2lib.h>
#include <RadioLib.h>

#include "configuration.h"

//====== Timer for periodical events u.a.
#include "Timeout.h"
Timeout timerSerial;

#define VERSION_STRING "PingPong v1.03" 

bool newData = false;

//=======================================================================================
#ifndef CONFIG_RADIO_OUTPUT_POWER
    #define CONFIG_RADIO_OUTPUT_POWER   10
#endif

#if defined(USING_SX1262)
    SX1262 radio = new Module(RADIO_CS_PIN, RADIO_DIO1_PIN, RADIO_RST_PIN, RADIO_BUSY_PIN);
#endif // USING_SX1262

#if defined(USING_SX1276)
    SX1276 radio = new Module(RADIO_CS_PIN, RADIO_DIO0_PIN, RADIO_RST_PIN, RADIO_DIO1_PIN);
#endif

static int transmissionState = RADIOLIB_ERR_NONE;  // save transmission state between loops
static volatile bool transmitFlag = false;  // flag to indicate transmission or reception state
volatile bool operationDone = false; // flag to indicate that a packet was sent or received


//static uint32_t counter = 0;
String payload;
static String TXpayload;
static String RXpayload;

// this function is called when a complete packet is transmitted by the module
// IMPORTANT: this function MUST be 'void' type and MUST NOT have any arguments!
#if defined(ESP8266) || defined(ESP32)
ICACHE_RAM_ATTR
#endif
void setFlag(void) { operationDone = true; } // we sent or received a packet

//static volatile bool receivedFlag = false;
static String rssi;
static String snr;

//=======================================================================================
uint8_t  display_address = 0x3c;    // It might be 0x3D
DISPLAY_MODEL *disp = NULL;
#define U8G2_HOR_ALIGN_CENTER(t)    ((disp->getDisplayWidth() -  (disp->getUTF8Width(t))) / 2)
#define U8G2_HOR_ALIGN_RIGHT(t)     ( disp->getDisplayWidth()  -  disp->getUTF8Width(t))

bool beginDisplay()
{
    Wire.beginTransmission(display_address);
    if (Wire.endTransmission() == 0) {
        disp = new DISPLAY_MODEL(U8G2_R0, U8X8_PIN_NONE);
        Serial.printf("Find Display model at 0x%X address\n", display_address);
        disp->begin();
        disp->clearBuffer();
        disp->setFont(u8g2_font_inb19_mr);
        disp->drawStr(0, 30, "LilyGo");
        disp->drawHLine(2, 35, 47);
        disp->drawHLine(3, 36, 47);
        disp->drawVLine(45, 32, 12);
        disp->drawVLine(46, 33, 12);
        disp->setFont(u8g2_font_inb19_mf);
        disp->drawStr(58, 60, "LoRa");
        disp->sendBuffer();
        disp->setFont(u8g2_font_fur11_tf);
        delay(3000);
        return true;
    }
    Serial.printf("Warning: Failed to find Display at 0x%0X address\n", display_address);
    return false;
}

//=======================================================================================
void drawMain()
{
    if (disp) {
        disp->clearBuffer();
        disp->drawRFrame(0, 0, 128, 64, 5);
        disp->setFont(u8g2_font_crox1h_tr);
        disp->setCursor(4, 12);   disp->print("TX:");
        disp->setCursor(4, 24);   disp->print("RX:");
        disp->setCursor(5, 36);   disp->print("STATE:");
        disp->setCursor(5, 48);   disp->print("RSSI:");
        disp->setCursor(5, 60);   disp->print("SNR:");

        disp->setCursor( U8G2_HOR_ALIGN_RIGHT(TXpayload.c_str()) - 5, 12 );
        disp->print(TXpayload);
        disp->setCursor( U8G2_HOR_ALIGN_RIGHT(RXpayload.c_str()) - 5, 24 );
        disp->print(RXpayload);

        String state = transmissionState == RADIOLIB_ERR_NONE ? "OK" : String(transmissionState);
        disp->setCursor( U8G2_HOR_ALIGN_RIGHT(state.c_str()) -  5, 36 );
        disp->print(state);
        disp->setCursor( U8G2_HOR_ALIGN_RIGHT(rssi.c_str()) - 5, 48 );
        disp->print(rssi);
        disp->setCursor( U8G2_HOR_ALIGN_RIGHT(snr.c_str()) - 5, 60 );
        disp->print(snr);
        disp->sendBuffer();
    }
}

//==============================================================================
char receivedChar;
const byte numChars = 250;
char inLine[numChars];   // an array to store the received data

//==============================================================================
void recvWithEndMarker() {
    static byte ndx = 0;
    char endMark1 = '\n'; // LF
    char endMark2 = '\r'; // CR
    char rc;
    bool endLine = false;
    
    while (Serial.available() > 0 && newData == false) {
        rc = Serial.read();
        Serial.print(rc);  // echo local
        endLine = ((rc == endMark1) || (rc == endMark2));

        if (!endLine) {
            inLine[ndx] = rc;
            ndx++;
            if (ndx >= numChars) {  // auf die def. Anzahl der Zeichen begrenzt
                ndx = numChars - 1;
            }
        } else {
            inLine[ndx] = '\0'; // terminate the string
            ndx = 0;
            newData = true;
        }
    }
}

//==============================================================================
std::string helpStr = "[D]Eingabe: :Text | +Befehl | ?Abfrage | ? Hilfe";
char strSendText[250]; // for LoRa
int isTXLORA = 1; // 0=off, 1=on, 2=auto
bool isTXLoRaStr = false; // flag for TX_LORA data
std::string fullLine;
std::string cmd;
std::string pars = "";
unsigned long int intval = 0;

void setParameter(char* inLine) {
    printf("[D]setParameter: %s\n",inLine);
    std::string para = inLine;
  
    // Eingabe zerteilen
    fullLine = inLine;
    size_t pos = fullLine.find(" ");
    if (pos != std::string::npos) {  //"cmd xxxxxx"
      cmd = fullLine.substr(0, pos);   //extract cmd
      pars = fullLine.erase(0, pos+1);       //remove cmd from input, remains pars
    } else { cmd = fullLine; }        //only "cmd"
    // pars "" of more parameters
    bool isInt = false;
    if (pars != "") {
      try
      {
        intval = stoul(pars);  // versuche Integer (stoi nur short)
        printf("[D] cmd='%s' pars='%s' intval=%lu\n", cmd.c_str(),pars.c_str(),intval);
        isInt = true;
      }
      catch(const std::exception& e)
      {
        intval = 0;
        printf("[D] cmd='%s' pars='%s'\n", cmd.c_str(),pars.c_str());      
      }
    }  
    
    //----------------------------------
    if ((cmd == "+TXpower") && (pars != "")) {
        printf("[D] set TXpower local to %lu\n", intval);
        if (radio.setOutputPower(intval) == RADIOLIB_ERR_INVALID_OUTPUT_POWER) {
            Serial.println("Selected output power is invalid for this module!"); }
    }  
    #ifdef USING_SX1262
    if ((cmd == "+RXboost") && (pars != "")) {
        if (pars == "on") radio.setRxBoostedGainMode(true);
        if (pars == "off") radio.setRxBoostedGainMode(false);
    }
    #endif

    if ((cmd == "+QRG") && (pars != "")) {
        printf("[D] set Frequency local to %.3f MHz\n", float(intval)/1000.0);
        if (radio.setFrequency(float(intval)/1000.0) == RADIOLIB_ERR_INVALID_FREQUENCY) {
            Serial.println("Selected frequency is invalid for this module!"); }
    }
}

void outputParameterabfrage(char* inLine) {}

void outputBefehlsliste() {
    Serial.println("[D]Befehlsliste ...");
    printf("\n[I]Befehlsliste:\n"); //CRLF
    printf("[I] ?                   list all commands\n");
    printf("[I] :textmessage        TX_LORA textmessage\n");
    printf("[I] :PING               fordert PONG an\n");
    printf("[I] :CLEAR              löscht Screen\n");
    printf("[I] :TXpower xx         set TXpower remote\n");
    printf("[I] :RXboost {on|off}   setRXboostedGain remote (SX1261/2 v2.1, SX1268 v1.1)\n");
    printf("[I] :QRG ffffff         setzt Frequenz [kHz] remote\n");
    printf("\n");
    printf("[I] +TXpower xx         set TXpower local\n");
    printf("[I] +RXboost {on|off}   setRXboostedGain local (SX1261/2 v2.1, SX1268 v1.1)\n");
    printf("[I] +QRG ffffff         setzt Frequenz [kHz] lokal\n");

    printf("[D]----------------------------------------------\n");
    // ...
  
}

void getTextToSend(char* inLine) {
    sprintf(strSendText, inLine);
    if (isTXLORA >0) {isTXLoRaStr = true;} // set flag for TX_LORA data
}

void Parser() {
  if (newData) {  // Eingabe erfolgt
    int num = strlen(inLine);
    if (num>0) {
      printf("[D] %i : %s\n",num,inLine); // echo input
      if ((inLine[0]=='?') && (num==1)) { outputBefehlsliste(); }
        else if ((inLine[0]=='?') && (num>=2)) { outputParameterabfrage(inLine); }
          else if ((inLine[0]=='+') && (num>=2)) { setParameter(inLine); }
            else if ((inLine[0]=='-') && (inLine[1]=='-') && (num>=3)) { setParameter(inLine); } // auch --befehl unterstützen
              else if (inLine[0]==':') { getTextToSend(inLine); }
                else { printf("[E] '%s' unbekannter Befehl\n",inLine); //CRLF
                       Serial.println(helpStr.c_str()); //CRLF
                }
    }
    newData = false;
  }
}

//=======================================================================================
void setup()
{
    timerSerial.start(2000);
    Serial.begin(115200);
    while (!Serial && !timerSerial.time_over());
    if (Serial) { for (int i=0;i<10;i++) { Serial.println("."); delay(1000); } }

    #ifdef I2C_SDA
        Wire.begin(I2C_SDA, I2C_SCL);
    #endif

    Serial.println("\nSetup Board");
    
    beginDisplay();

    Serial.println(VERSION_STRING);
    #if defined(HAS_SDCARD) && defined(SD_SHARE_SPI_BUS)
        // Share spi bus with lora , set lora cs,rst to high
        pinMode(RADIO_CS_PIN, OUTPUT);
        pinMode(RADIO_RST_PIN, OUTPUT);
        digitalWrite(RADIO_CS_PIN, HIGH);
        digitalWrite(RADIO_RST_PIN, HIGH);
    #endif

    #ifdef RADIO_LDO_EN
        // T-BEAM-1W Control SX1262, LNA, must set RADIO_LDO_EN to HIGH to power the Radio
        pinMode(RADIO_LDO_EN, OUTPUT);
        digitalWrite(RADIO_LDO_EN, HIGH);
        delay(500);
    #endif

    #ifdef RADIO_CTRL
        // T-BEAM-1W LoRa RX/TX Control.
        // RADIO_CTRL = HIGH Only when RX DATA to turn on LNA.
        // RADIO_CTRL = LOW when TX DATA to turn off LNA
        pinMode(RADIO_CTRL, OUTPUT);
        digitalWrite(RADIO_CTRL, HIGH);  // RX Mode
        delay(500);
    #endif

    SPI.begin(RADIO_SCLK_PIN, RADIO_MISO_PIN, RADIO_MOSI_PIN);

    Serial.println("... radio.begin ...");
    int state = radio.begin(CONFIG_RADIO_FREQ);    // initialize radio with default settings
    Serial.printf("... radio state: %u\n", state);

    //radio.setTCXO(3.0);

    Serial.printf("[%s]:", RADIO_TYPE_STR);
    Serial.print("Radio Initializing ... ");
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println("success!");
    } else {
        Serial.printf("failed, code %u >>>>>> stopped", state);
        while (true);
    }

    /*
    // set the function that will be called when packet transmission is finished
    radio.setPacketSentAction(setTXflag);

    // set the function that will be called when new packet is received
    radio.setPacketReceivedAction(setRXflag);
    */
   
    #if defined(T3_V1_6_SX1276) || defined(T3_V1_6_SX1278)
        // set the function that will be called when new packet is received
        radio.setDio0Action(setFlag, RISING);
    #endif

    #if defined(USING_SX1262)
        // set the function that will be called when new packet is received
        radio.setDio1Action(setFlag);
    #endif

    // Sets carrier frequency.
    // SX1268/SX1262 : Allowed values are in range from 150.0 to 960.0 MHz
    // SX1278/SX1276 : Allowed values range from 137.0 MHz to 525.0 MHz.
    if (radio.setFrequency(CONFIG_RADIO_FREQ) == RADIOLIB_ERR_INVALID_FREQUENCY) {
        Serial.println("Selected frequency is invalid for this module! >>>>> stopped");
        while (true);
    }

    // Sets LoRa link bandwidth.
    // SX1268/SX1262 : Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125.0, 250.0 and 500.0 kHz
    // SX1278/SX1276 : Allowed values are 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125, 250 and 500 kHz. Only available in %LoRa mode.
    if (radio.setBandwidth(CONFIG_RADIO_BW) == RADIOLIB_ERR_INVALID_BANDWIDTH) {
        Serial.println("Selected bandwidth is invalid for this module! >>>>> stopped");
        while (true);
    }

    // SX1262 : LoRa link spreading factor allowed values range from 5 to 12
    // SX1278/SX1276 :  Allowed values range from 6 to 12. Only available in LoRa mode.
    if (radio.setSpreadingFactor(CONFIG_RADIO_SF) == RADIOLIB_ERR_INVALID_SPREADING_FACTOR) {
        Serial.println("Selected spreading factor is invalid for this module! >>>>> stopped");
        while (true);
    }

    // Sets LoRa coding rate denominator.
    // SX1278/SX1276/SX1268/SX1262 : Allowed values range from 5 to 8. Only available in LoRa mode
    if (radio.setCodingRate(CONFIG_RADIO_CR) == RADIOLIB_ERR_INVALID_CODING_RATE) {
        Serial.println("Selected coding rate is invalid for this module! >>>>> stopped");
        while (true);
    }

    // Sets LoRa sync word.
    // SX1278/SX1276/SX1268/SX1262/SX1280 : Sets LoRa sync word. Only available in LoRa mode
    if (radio.setSyncWord(CONFIG_RADIO_SW) != RADIOLIB_ERR_NONE) {
        Serial.println("Unable to set sync word! >>>>> stopped");
        while (true);
    }

    // Sets transmission output power.
    // SX1262 :  Allowed values are in range from -9 to 22 dBm.
    //     This method is virtual to allow override from the SX1261 class
    // SX1278/SX1276 :  Allowed values range from -3 to 15 dBm (RFO pin) or +2 to +17 dBm (PA_BOOST pin).
    //     High power +20 dBm operation is also supported, on the PA_BOOST pin. Defaults to PA_BOOST.
    if (radio.setOutputPower(CONFIG_RADIO_OUTPUT_POWER) == RADIOLIB_ERR_INVALID_OUTPUT_POWER) {
        Serial.println("Selected output power is invalid for this module! >>>>> stopped");
        while (true);
    }

    // Sets current limit for over current protection at transmitter amplifier.
    // SX1262/SX1268 : Allowed values range from 45 to 120 mA in 2.5 mA steps and 120 to 240 mA in 10 mA steps
    // SX1278/SX1276 : Allowed values range from 45 to 120 mA in 5 mA steps and 120 to 240 mA in 10 mA steps.
    // NOTE: set value to 0 to disable overcurrent protection
    if (radio.setCurrentLimit(140) == RADIOLIB_ERR_INVALID_CURRENT_LIMIT) {
        Serial.println("Selected current limit is invalid for this module! >>>>> stopped");
        while (true);
    }

    // Sets preamble length for LoRa or FSK modem.
    // SX1262/SX1268 : Allowed values range from 1 to 65535.
    // SX1278/SX1276 : Allowed values range from 6 to 65535 in LoRa mode or 0 to 65535 in FSK mode.
    if (radio.setPreambleLength(CONFIG_RADIO_PRE) == RADIOLIB_ERR_INVALID_PREAMBLE_LENGTH) {
        Serial.println("Selected preamble length is invalid for this module! >>>>> stopped");
        while (true);
    }

    // Enables or disables CRC check of received packets.
    if (radio.setCRC(false) == RADIOLIB_ERR_INVALID_CRC_CONFIGURATION) {
        Serial.println("Selected CRC is invalid for this module! >>>>> stopped");
        while (true);
    }


#ifdef RADIO_CTRL
    Serial.println("Turn on LNA, Enter Rx mode.");
    digitalWrite(RADIO_CTRL, HIGH);  // RX mode
#endif /*RADIO_CTRL*/

    delay(1000);

    Serial.println("Setup finished");

    // start listening for LoRa packets
    Serial.print("Radio Starting to listen ... ");
    state = radio.startReceive();
    if (state == RADIOLIB_ERR_NONE) {
        Serial.println("success!");
    } else {
        Serial.printf("failed, code %u\n", state);
    }

    TXpayload = VERSION_STRING;
    RXpayload = String(CONFIG_RADIO_FREQ,3)+" MHz";
    snr = "";
    rssi = "";
    drawMain();
}

//=======================================================================================
void loop()
{
    recvWithEndMarker();        // Befehlseingaben abfragen und verarbeiten
    if (newData) { Parser(); }  // CLI eine Zeichenfolge bis cr|lf empfangen & parsen

    if (isTXLoRaStr) {
        isTXLoRaStr = false;

        TXpayload = String(strSendText);
        RXpayload = "";  // ev. nur löschen, wenn kein Response?+QR
        snr = "";
        rssi = "";
        drawMain();

        #ifdef RADIO_CTRL
            Serial.println("Turn off LNA, Turn on PA, Enter Tx mode.");
            digitalWrite(RADIO_CTRL, LOW);  // TX mode
        #endif /*RADIO_CTRL*/
        Serial.printf("Radio Sending packet: %s ... ", TXpayload.c_str());
        delay(200);  // wait a moment before transmitting
        transmissionState = radio.startTransmit(TXpayload);
        transmitFlag = true;
    }

    if(operationDone) {
        operationDone = false;  // reset flag
    
        if (transmitFlag) {    // check if the previous transmission finished
            // the previous operation was transmission, listen for response, print the result
        
            if (transmissionState == RADIOLIB_ERR_NONE) {
                Serial.println("transmission finished!");  // packet was successfully sent
                // NOTE: when using interrupt-driven transmit method,
                // it is not possible to automatically measure transmission data rate using getDataRate()
            } else { Serial.printf("failed, code %u\n", transmissionState); }

            #ifdef RADIO_CTRL
                Serial.println("Turn on LNA, Enter Rx mode.");
                digitalWrite(RADIO_CTRL, HIGH);  // RX mode
            #endif /*RADIO_CTRL*/
            delay(200);
            transmitFlag = false;  // reset flag
            radio.startReceive();  // listen for response
            
        } else {  // the previous operation was reception, print data and send another packet
            int state = radio.readData(payload);

            if (state == RADIOLIB_ERR_NONE) {  // packet was successfully received

                rssi = String(radio.getRSSI()) + " dBm";
                snr = String(radio.getSNR()) + " dB";
                RXpayload = payload;
                drawMain();

                Serial.printf("Radio Received packet: %s |RSSI: %s SNR: %s\n", 
                                RXpayload.c_str(), rssi.c_str(), snr.c_str());

                if (RXpayload == ":PING") {
                    sprintf(strSendText, "PONG %s %s", String(radio.getRSSI()).c_str(),String(radio.getSNR()).c_str());
                    TXpayload = String(strSendText);
                    drawMain();
                    isTXLoRaStr = true;        
                }

                if (RXpayload == ":CLEAR") {
                    TXpayload = "";
                    RXpayload = "";
                    snr = "";
                    rssi = "";
                    drawMain();
                    //isTXLoRaStr = false;        
                }

                strncpy(inLine, RXpayload.c_str(), sizeof(inLine));
                setParameter(inLine);
                
                if (cmd == ":TXpower") {
                    if (radio.setOutputPower(intval) == RADIOLIB_ERR_INVALID_OUTPUT_POWER) {
                        Serial.println("Selected output power is invalid for this module!"); }
                    sprintf(strSendText, "TXpower %s", String(intval).c_str()); //response
                    isTXLoRaStr = true; 
                }

                #ifdef USING_SX1262
                if ((cmd == ":RXboost") && (pars != "")) {
                    if (pars == "on") radio.setRxBoostedGainMode(true);
                    if (pars == "off") radio.setRxBoostedGainMode(false);
                    sprintf(strSendText, "RXboost %s", pars.c_str()); //response
                    isTXLoRaStr = true; 
                }
                #endif
            
                if ((cmd == ":QRG") && (pars != "")) {
                    if (radio.setFrequency(intval/1000.0) == RADIOLIB_ERR_INVALID_FREQUENCY) {
                        Serial.println("Selected frequency is invalid for this module!"); }
                    sprintf(strSendText, "QRG %s kHz", pars.c_str()); //response
                    isTXLoRaStr = true; 
    
                }
                            

            } else if (state == RADIOLIB_ERR_CRC_MISMATCH) {
                Serial.println("CRC error!");  // packet was received, but is malformed
            } else {
                Serial.printf("failed, code %u\n", state);  // some other error occurred
            }

            radio.startReceive(); // put module back to listen mode
        }
    }
}
